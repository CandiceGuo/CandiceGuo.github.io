{"meta":{"title":"Candice' Blog","subtitle":"I love my father forever.","description":"I love my father forever.","author":"CandiceGuo","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-08-13T02:29:40.000Z","updated":"2017-08-13T02:30:08.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-08-11T08:49:21.000Z","updated":"2017-08-11T09:10:43.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-08-11T08:49:39.000Z","updated":"2017-08-11T09:10:38.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CS224 lesson2—Main Line","slug":"CS224-lesson2—Main-Line","date":"2017-08-20T17:02:52.000Z","updated":"2017-08-20T17:29:21.000Z","comments":true,"path":"2017/08/21/CS224-lesson2—Main-Line/","link":"","permalink":"http://yoursite.com/2017/08/21/CS224-lesson2—Main-Line/","excerpt":"The first and arguably most important common denominator across all NLP tasks is how we represent words as input to any of our models. 本章节主要通过 ”How to represent words?“ 这一话题展开","text":"The first and arguably most important common denominator across all NLP tasks is how we represent words as input to any of our models. 本章节主要通过 ”How to represent words?“ 这一话题展开 思路One-Hot Vector There are an estimated 13 million(1.3亿）tokens for the English language.（1） 上面的 fact ，我们可以对word形成最简单的理解，若给每个word标记一个index，单词的表示方式为$$w_i = (0,0,…,0,1,0,…,0,0)^T ( 0&lt;= i &lt; |V|)$$|v|表示单词表中的单词总量，index = i位置为1表示：wi为单词表中index = i处的单词。 这种向量我们称为 one-hot vector 此时我们想到 All of the words are not completely unrelated. If we encode all semantics of our language, perhaps there actually exists some N-dimensional space and N &lt;&lt; 13 million. 然而one-hot vector 引起的问题是： One-hot vector represent each word as a completely independent entity. For instance,$$(w^{hotel})^Tw^{motel} = (w^{hotel})^Tw^{cat} = 0$$This word representation does not give us directly any idea of the relationship of two different words. The dimensions of one-hot vector is really big. They are beyond the limits of computer ability. 此时我们顿悟到我们需要的representation of the word 有以下几个特点 The dimension should be as small as possible and the computer can easily handle these vectors. This kind of word representation can give us any directly notion of the word similariy Word Representation Based on SVD​ 由上面的叙述可知，我们更想找到的是一种word embeddings方法，也就是说我们更想知道的是能否存在某种向量可以 find a subspace that can encode the relationships between words， 这种关系可以更形象的称之为“语义”（Semantic）。而SVD（Singular Value Decomposition)方法可以帮助我们。 ​ 为了形成解决思路，我们首先看一下SVD的表达式$$A = U\\sum V^T$$​ 通过上面这个公式，我们可以直观的看到SVD算法似乎是将一个矩阵分解成了几个向量的乘积的形式。而分解的结果我们可以通过下图看到，","categories":[{"name":"CS224学习","slug":"CS224学习","permalink":"http://yoursite.com/categories/CS224学习/"}],"tags":[{"name":"学术","slug":"学术","permalink":"http://yoursite.com/tags/学术/"},{"name":"NLP","slug":"NLP","permalink":"http://yoursite.com/tags/NLP/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://yoursite.com/tags/DeepLearning/"},{"name":"CS224","slug":"CS224","permalink":"http://yoursite.com/tags/CS224/"}]},{"title":"java基础(1)","slug":"java基础-1","date":"2017-08-11T08:41:57.000Z","updated":"2017-08-11T08:44:28.000Z","comments":true,"path":"2017/08/11/java基础-1/","link":"","permalink":"http://yoursite.com/2017/08/11/java基础-1/","excerpt":"","text":"java基础java语言的优点 “平台无关性”：java语言可以一次编译到处运行，意思就是编译后的代码可以再多种平台上运行，由于java是解释型语言，编译器会把java代码编程为中间代码，然后在java虚拟机中运行，因此java可以跨平台 行，具有良好的可移植性 我的理解是:编辑器将java代码编译成适合于不同平台的中间代码 对public static void main(String[] args)理解？public: 对任何类和对象都可以访问这个方法。static : 表明main方法是一个静态方法，方法中的代码是存储在静态存储区的只要类被加载后，说明代码就加载到了静态区域，就可以直接通过类名.main()直接访问， JVM启动后就可以按照上述方法的签名来找到方法的入口地址，找到就执行，找不到就报错。 java程序是怎样运行的？java初始化：（1）静态变量 先于 非静态变量 ，静态对象只初始化一次，非晶态的会初始化很多次父类 先于 子类变量 先于 代码块==&gt; 父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态代码块，父类构造函数、子类非晶态变量、子类非晶态代码块、子类构造函数 java创建对象 new 创建new 操作符的本意就是创建一个对象，首先看new后面的数值类型，知道了类型，然后才知道要分配多大的内存空间，分配完内存之后，再调用构造函数，填充这个对象的各个域（初始化），一个对象创建完毕后，把它的引用发布到外部去，在外部就可以通过引用来操纵这个对象。new 创建的对象本体都在堆区，堆区主要放对象栈区放引用 clone分配内存都一样，但是内存的大小是根据调用clone方法的对象的大小相同，然后再使用原对象对应的各个域，填充新对象，引用发布出去浅clone: 如果对象中有些域也是引用，那么clone的只是引用深clone: 因为有个super.clone(), 会引发引用指向的值都clone需要实现Cloneable接口，实现clone方法，并且在这个方法内部，把该对象引用的其他对象也clone因为有个super.clone(), 会引发引用指向的值都clone 什么是反射机制反射机制就是在程序运行时能够获取自身的信息，反射机制的作用（1) 反编译： .class –&gt; .java (2) 通过反射机制来访问java对象的属性、方法、构造方法等。 反射机制的类： java.lang.Class java.lang.reflect.Constructor java.lang.reflect.Field java.lang.reflect.Modifier 一般步骤：先获取到类 Class c = Class.forName(“xxx”) 然后在获取这个类中的信息 java泛型独特之处：java泛型只在程序源码中存在，在编译后的字节码文件中，都已经被替换为原来的原始类型（就是指被擦除了类型的泛型），并在相应的位置插入了强行转型代码。用反射机制理解：在程序中定义了一个ArrayList泛型类型实例化为Integer的对象，如果直接调用add方法，那么只能存储整形的数据。不过当我们利用反射调用add方法的时候，却可以存储字符串。Array不支持泛型，一般用List来代替Array 多态实现问题？编译时多态运行时多态 动态绑定&amp;&amp;静态绑定用private, static,final修饰变量或者方法时，采用的是静态绑定重载的方法是使用静态绑定完成，而重写的方法使用的是动态绑定有利于java的效率 抽象类与接口类(1) 抽象类和接口都不能实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。(2) 抽象类可以有普通成员变量，构造方法，静态方法，非抽象类的普通方法，接口中没有，而且只有抽象方法(3) 都可以含有静态变量，接口类的变量只能是public static fianl抽象类的静态成员变量访问类型可以是非public(4)可以实现多个接口，但只能继承一个抽象类。(5) 抽象类对类抽象，接口是对行为抽象 final 理解(1) final 为用于标识变量的关键字，final标识的存储在常量池里(2) final不能被子类的方法覆盖，但可以被继承。(3) final 成员变量表示常量，赋值后不再改变(4) final类不能被继承，防止任何继承类修改它的意义和实现 static理解static表示全局，修饰成员变量和成员方法， volatile关键字并发编程instanceof作用字符串创建与存储文件异常处理数据库基础maven相关操作网络相关知识","categories":[{"name":"java开发","slug":"java开发","permalink":"http://yoursite.com/categories/java开发/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"语言","slug":"语言","permalink":"http://yoursite.com/tags/语言/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-11T07:47:37.000Z","updated":"2017-08-13T07:38:02.000Z","comments":true,"path":"2017/08/11/hello-world/","link":"","permalink":"http://yoursite.com/2017/08/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}